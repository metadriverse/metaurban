# Manually place asset into a static scene
# from metaurban.component.traffic_participants.pedestrian import Pedestrian
# from metaurban.envs.metaurban_env import metaurbanEnv
from metaurban.envs import SidewalkmetaurbanEnv, SidewalkStaticmetaurbanEnv
from metaurban.component.static_object.test_new_object import TestObject, TestGLTFObject
from asset.read_config import configReader
from metaurban.component.sensors.rgb_camera import RGBCamera
from metaurban.component.static_object.test_new_object import TestObject, TestGLTFObject
from metaurban.envs import SidewalkmetaurbanEnv, SidewalkStaticmetaurbanEnv
from asset.read_config import configReader
import os
import json
import tkinter as tk
import math
import cv2
class AssetAdjuster:
    def __init__(self, env_config, folder_path, save_path):
        """
        Initialize the AssetAdjuster.

        :param env_config: Configuration for the metaurban environment.
        :param folder_path: Path to the folder containing asset JSON files generated by objverse_change_asset_script.py
        :param save_path: Path to save the position and other information for each asset placed.
        """
        self.env = SidewalkmetaurbanEnv(env_config)
        self.folder_path = folder_path
        self.env.reset()
        self.current_obj = None
        self.save_path = save_path
        self.t = 0
        self.load_and_display_objects()
        self.files = [file for file in os.listdir(folder_path) if file.endswith(".json")]
        self.current_index = 0
    @staticmethod
    def load_json_file(filepath):
        """
        Load a JSON file and return its content.

        Parameters:
        - filepath (str): The path to the JSON file to be loaded.

        Returns:
        - dict: A dictionary containing the data loaded from the JSON file.
        """
        with open(filepath, 'r') as f:
            return json.load(f)

    def display_files(self):
        """
        Display a window with a list box containing all JSON files for selection.
        """
        window = tk.Tk()
        window.title("Select Files to Adjust")

        listbox = tk.Listbox(window, selectmode=tk.MULTIPLE, width=50, height=15)
        listbox.pack(pady=20)

        for file in self.files:
            listbox.insert(tk.END, file)

        def on_process_selected():
            selections = listbox.curselection()
            selected_files = [self.files[i] for i in selections]
            if not selected_files:
                messagebox.showinfo("No selection", "Please select at least one file.")
                return
            window.destroy()
            for file in selected_files:
                self.current_index = self.files.index(file)
                self.process_next()

        process_btn = tk.Button(window, text="Process Selected", command=on_process_selected)
        process_btn.pack(pady=20)

        window.mainloop()

    def load_and_display_objects(self):
        """
        Load and display objects using saved meta information.
        If you have previously use this python script to place items.
        This function will be called initially and serve as a "resume game" function
        It will place the asset you have privously placed again.
        """
        if not os.path.exists(self.save_path):
            print(f"Save file '{self.save_path}' does not exist.")
            return

        with open(self.save_path, 'r') as f:
            saved_data = json.load(f)

        for filepath, params_list in saved_data.items():
            asset_metainfo = self.load_json_file(filepath)
            for params in params_list:
                x = params['x']
                y = params['y']
                theta = params['theta']
                if "foldername" in asset_metainfo.keys() and asset_metainfo["foldername"] is not None:
                    self.env.engine.spawn_object(TestGLTFObject, position=[x, y], heading_theta=theta, random_seed=1,
                                                 force_spawn=True, asset_metainfo=asset_metainfo)
                else:
                    self.env.engine.spawn_object(TestObject, position=[x, y], heading_theta=theta, random_seed=1,
                                                 force_spawn=True, asset_metainfo=asset_metainfo)

    def add_same_asset(self, filepath):
        """
        Adjust parameters for adding a new instance of the same asset.

        Parameters:
        - filepath (str): The path to the JSON file of the asset.
        """
        self.adjust_parameters(filepath)
    def spawn_object(self, x, y, theta, asset_metainfo):
        """
        Spawn an object in the environment with specified position and rotation.

        Parameters:
        - x (float): X position of the object.
        - y (float): Y position of the object.
        - theta (float): Rotation angle of the object in radians.
        - asset_metainfo (dict): Metadata about the asset, used for spawning.
        """
        if self.current_obj is not None:
            self.env.engine.clear_objects([self.current_obj.id], force_destroy=True)
        if "foldername" in asset_metainfo.keys() and asset_metainfo["foldername"] is not None:
            self.current_obj = self.env.engine.spawn_object(TestGLTFObject, position=[x, y], heading_theta=theta,
                                                            random_seed=1, force_spawn=True,
                                                            asset_metainfo=asset_metainfo)
        else:
            self.current_obj = self.env.engine.spawn_object(TestObject, position=[x, y], heading_theta=theta,
                                                            random_seed=1, force_spawn=True,
                                                            asset_metainfo=asset_metainfo)

    def load_saved_values(self, filepath):
        """
        Load saved position and orientation values for a specific asset.

        Parameters:
        - filepath (str): Path to the asset's JSON file.

        Returns:
        - dict: A dictionary containing the last saved values for the asset. If no values are saved, returns an empty dictionary.
        """
        output_filename = self.save_path
        if os.path.exists(output_filename):
            with open(output_filename, 'r') as f:
                data = json.load(f)
            # Get the last set of values for this filepath, or an empty dictionary if none exists
            return data.get(filepath, [{}])[-1]
        return {}
    def onlyStep(self, capture=False, pic_name_id=1):
        """
        Onle execute steps in the environment (without adjust additional object) and optionally capture screenshots.

        Parameters:
        - capture (bool): If True, captures screenshots of the environment.
        - pic_name_id (int): Identifier used to name the captured image files.
        """
        step = 0
        camera = self.env.engine.get_sensor("rgb")
        while True:
            o, r, tm, tc, info = self.env.step([0, 0])
            if capture:
                # self.env.capture("spawned{}_obj_{}.jpg".format(pic_name_id, step))
                # rgb_sidewalk = camera.perceive(to_float=True, new_parent_node=self.env.agent.origin, position=(10., -3, 1.5),
                #                       hpr=[0, 0, 0])
                # rgb_topdown = camera.perceive(to_float=True, new_parent_node=self.env.agent.origin, position=(10, 15, 25),
                #                       hpr=[0, 270, 0])
                # rgb_sidewalk = camera.perceive(to_float=True, new_parent_node=self.env.agent.origin, position=(13., -2, 1.5),
                #                       hpr=[0, 0, 0])
                # rgb_topdown = camera.perceive(to_float=True, new_parent_node=self.env.agent.origin, position=(10, 15, 25),
                #                       hpr=[0, 270, 0])
                # rgb_sidewalk = camera.perceive(to_float=True, new_parent_node=self.env.agent.origin, position=(-10., 65, 1.5),
                #                       hpr=[30, 0, 0])
                # rgb_topdown = camera.perceive(to_float=True, new_parent_node=self.env.agent.origin, position=(-20, 80, 30),
                #                       hpr=[0, 270, 0])
                rgb_sidewalk = camera.perceive(to_float=True, new_parent_node=self.env.agent.origin, position=(-10., 70, 1.5),
                                      hpr=[-30, 0, 0])
                rgb_topdown = camera.perceive(to_float=True, new_parent_node=self.env.agent.origin, position=(-0, 80, 30),
                                      hpr=[0, 270, 0])
                rgb_sidewalk = rgb_sidewalk * 255
                rgb_topdown = rgb_topdown * 255
                # save rgb image
                print("save image to D:\\research\\dataset\\recording\\imagespawned{}_obj.jpg".format(pic_name_id, step))
                cv2.imwrite("D:\\research\\dataset\\recording\\topdownspawned{}_obj_{}.jpg".format(pic_name_id, step), rgb_topdown)
                cv2.imwrite("D:\\research\\dataset\\recording\\sidewalkspawned{}_obj_{}.jpg".format(pic_name_id, step),
                            rgb_sidewalk)
            step += 1
    def adjust_parameters(self, filepath):
        """
        Adjust parameters of an asset using a GUI interface. Allows for manual positioning and rotation of the asset.

        Parameters:
        - filepath (str): Path to the JSON file of the asset.
        """
        asset_metainfo = self.load_json_file(filepath)
        saved_values = self.load_saved_values(filepath)

        def on_scale_change(val, entry):
            entry.delete(0, tk.END)
            entry.insert(0, val)
            x = x_scale.get()
            y = y_scale.get()
            theta = theta_scale.get()
            self.spawn_object(x, y, theta, asset_metainfo)

        def on_entry_change(entry, scale):
            try:
                scale_val = float(entry.get())
                scale.set(scale_val)
            except ValueError:
                pass  # You may want to provide a user feedback about invalid input
        def update_env():
            self.t = self.t + 1
            o, r, tm, tc, info = self.env.step([0, 0])
            # self.env.capture("spawned_obj_{}.jpg".format(self.t))
            root.after(20, update_env)  # Calls itself every 50 milliseconds. Adjust this interval as needed.


        root = tk.Tk()
        root.title("Adjust parameters for " + filepath)

        def on_submit():
            x_val = x_scale.get()
            y_val = y_scale.get()
            theta_val = theta_scale.get()
            self.save_to_json(x_val, y_val, theta_val, filepath)
            self.current_obj = None  # Prevent clearing the object when spawning next
            root.destroy()

        def on_submit_and_next():
            on_submit()
            # self.current_index += 1
            self.display_files()

        def on_submit_and_add_same():
            on_submit()
            # No need to increment the current_index
            self.adjust_parameters(filepath)

        submit_and_next_btn = tk.Button(root, text="Submit and Next", command=on_submit_and_next)
        submit_and_next_btn.pack(pady=20)

        submit_and_add_same_btn = tk.Button(root, text="Submit and Add Same", command=on_submit_and_add_same)
        submit_and_add_same_btn.pack(pady=20)

        next_asset_btn = tk.Button(root, text="Next Asset", command=lambda: self.go_to_next_asset(root))
        next_asset_btn.pack(pady=20)
        x_default = saved_values.get('x', 10)
        y_default = saved_values.get('y', -5)
        theta_default = saved_values.get('theta', 0)

        x_scale = tk.Scale(root, from_=-500, to=500, orient=tk.HORIZONTAL, length=300, sliderlength=30)
        x_scale.set(x_default)
        x_scale.pack(pady=20)

        x_entry = tk.Entry(root)
        x_entry.insert(0, x_scale.get())
        x_entry.bind('<Return>', lambda e: on_entry_change(x_entry, x_scale))
        x_scale.config(command=lambda val: on_scale_change(val, x_entry))
        x_entry.pack(pady=10)

        y_scale = tk.Scale(root, from_=-500, to=500, orient=tk.HORIZONTAL, length=300, sliderlength=30)
        y_scale.set(y_default)
        y_scale.pack(pady=20)

        y_entry = tk.Entry(root)
        y_entry.insert(0, y_scale.get())
        y_entry.bind('<Return>', lambda e: on_entry_change(y_entry, y_scale))
        y_scale.config(command=lambda val: on_scale_change(val, y_entry))
        y_entry.pack(pady=10)

        theta_scale = tk.Scale(root, from_=-math.pi, to=math.pi, orient=tk.HORIZONTAL, label="Heading Theta", length=300, sliderlength=30, resolution=0.01)
        theta_scale.set(theta_default)
        theta_scale.pack(pady=20)

        theta_entry = tk.Entry(root)
        theta_entry.insert(0, theta_scale.get())
        theta_entry.bind('<Return>', lambda e: on_entry_change(theta_entry, theta_scale))
        theta_scale.config(command=lambda val: on_scale_change(val, theta_entry))
        theta_entry.pack(pady=10)

        update_env()  # Start the loop to update the environment
        root.mainloop()

    def process_next(self):
        """
        Overload of process_next to process the current asset in the list or a specific file if provided.
        """
        if self.current_index < len(self.files):
            print("================Dealing with: {}".format(self.files[self.current_index]))
            filepath = os.path.join(self.folder_path, self.files[self.current_index])
            self.adjust_parameters(filepath)

    def process_folder(self):
        """
        Initiates the process of adjusting assets in a folder.
        This method serves as the starting point for batch processing assets for adjustment.
        """
        self.process_next()
    def go_to_next_asset(self, root):
        """
        Skip to the next asset in the list, bypassing the current one.

        Parameters:
        - root (tk.Tk): The Tkinter root window, used for GUI interactions.
        """
        if self.current_obj is not None:
            self.env.engine.clear_objects([self.current_obj.id], force_destroy=True)
        self.current_obj = None
        root.destroy()
        self.current_index += 1
        self.display_files()

    def save_to_json(self, x, y, theta, filepath):
        """
        Save the adjusted position and orientation parameters of an asset to a JSON file.

        Parameters:
        - x (float): Adjusted X position of the object.
        - y (float): Adjusted Y position of the object.
        - theta (float): Adjusted rotation angle of the object in radians.
        - filepath (str): Path to the JSON file where the adjusted parameters will be saved.
        """
        output_filename = self.save_path
        if os.path.exists(output_filename):
            with open(output_filename, 'r') as f:
                data = json.load(f)
        else:
            data = {}

        # Check if this filepath already exists in the data
        if filepath not in data:
            data[filepath] = []

        data[filepath].append({
            'x': x,
            'y': y,
            'theta': theta
        })

        # Write updated data back to the JSON file
        with open(output_filename, 'w') as f:
            json.dump(data, f, indent=4)



if __name__ == "__main__":
    env_config = dict(
        object_density=0.3,
        use_render=True,
        # map="XCTCS",
        map="SSXT",
        manual_control=True,
        crswalk_density=1,
        spawn_human_num=2,
        spawn_robotdog_num=2,
        height_scale = 1,
        spawn_deliveryrobot_num=2,
        show_mid_block_map=False,
        show_ego_navigation=False,
        debug=True,
        horizon=300,
        on_continuous_line_done=False,
        out_of_route_done=True,
        vehicle_config=dict(
            show_lidar=False,
            show_navi_mark=True,
            show_line_to_navi_mark=True,
            show_dest_mark=True,
        ),
        show_sidewalk=True,
        show_crosswalk=True,
        # scenario setting
        random_spawn_lane_index=False,
        num_scenarios=1,
        traffic_density=0,
        accident_prob=0,
        window_size=(1600, 1100),
        relax_out_of_road_done=True,
        max_lateral_dist=3.0,
    )
    config = configReader()

    path_config = config.loadPath()
    asset_folder_path = path_config["assetfolder"]
    folder_path = path_config["adj_parameter_folder"]
    save_path = os.path.join(path_config["layout_static_info_folder"], "spawn_object2.json")
    print(save_path)
    adjuster = AssetAdjuster(env_config, folder_path, save_path)
    # call process folder if you want to place new items
    adjuster.display_files()
    # call onlystep if you just want to see current scene and take screenshot
    # adjuster.onlyStep(capture=True, pic_name_id=2)
